64.go.ver1 - аппроксимация решения с помощью аппроксимации TSP примом 2 раза и с ручной подгонкой
64.go.ver3 - проходим по всем двойкам ребер из предыдущего решения. 
Если 1 ребро v11 -- v12, 2 ребро v21 -- v22, то смотрим, можно ли поменять ребра на v11 -- v21 v12 -- v22 или на v11 -- v22 v12 -- v21 с улучшением cost. Прогоняем несколько раз.
64.go - дикая рандомизация предыдущего решения, всякие константы в циклах подгоняются руками
check.rb - проверяет выходной файл на валидность(4-регулярность, используются ли все вершины)

3 этапа:
1. Решаем аппроксимацию TSP для графа, удаляем вершины, решаем TSP ещё раз. Объединяем 2 решения в 1 граф, чтоб получить степень вершин 4.
2. Проходим по всем ребрам графа из предыдущего пункта. Пусть ei ej 2 ребра с вершинами v11 v12 и v21 v22 соответственно. Пытаемся поменять ребра на v11 v21 и v12 v22 или v11 v22 и v12 v21, если это возможно и если уменьшается вес графа. Делаем так пока это возможно.
3. Рандомайз - как-то портим граф путем такой же перестановки вершин, но не смотря на вес, а потом применяем к этому графу алгоритм из 2 пункта.
